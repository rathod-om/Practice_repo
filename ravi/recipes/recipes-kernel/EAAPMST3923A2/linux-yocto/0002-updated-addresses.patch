From 03f2ac403e8e608b8beed8fdd8a163deb52af11b Mon Sep 17 00:00:00 2001
From: om <om.rathod@einfochips.com>
Date: Fri, 19 Sep 2025 15:25:53 +0530
Subject: [PATCH 2/2] updated addresses

---
 drivers/iio/light/eaapmst3923a2.c | 199 ++++++++++++++++--------------
 1 file changed, 105 insertions(+), 94 deletions(-)

diff --git a/drivers/iio/light/eaapmst3923a2.c b/drivers/iio/light/eaapmst3923a2.c
index 67f34bf51a64..8822dfea84a4 100644
--- a/drivers/iio/light/eaapmst3923a2.c
+++ b/drivers/iio/light/eaapmst3923a2.c
@@ -2,76 +2,79 @@
  * EAAPMST3923A2 Ambient Light + Proximity Sensor Driver (skeleton)
  * For BeagleBone Black (I2C client)
  */
-
 #include <linux/module.h>
 #include <linux/i2c.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
 #include <linux/regmap.h>
+#include <linux/delay.h>
 
-#define EAAPMST3923A2_REG_ALS_LOW   0x0C
-#define EAAPMST3923A2_REG_ALS_HIGH  0x0D
-#define EAAPMST3923A2_REG_PS_LOW    0x08
-#define EAAPMST3923A2_REG_PS_HIGH   0x09
-#define EAAPMST3923A2_REG_ENABLE    0x00
+#define EAAPMST3923A2_REG_CONFIG    0x01
+#define EAAPMST3923A2_REG_PS_DATA   0x08
+#define EAAPMST3923A2_REG_ALS_LOW   0x09
+#define EAAPMST3923A2_REG_ALS_HIGH  0x0A
+#define EAAPMST3923A2_REG_ALS_RANGE 0x0B
 
 struct eaapmst3923a2_data {
-	struct regmap *regmap;
-	struct i2c_client *client;
+        struct regmap *regmap;
+        struct i2c_client *client;
 };
 
 /* IIO read function */
 static int eaapmst3923a2_read_raw(struct iio_dev *indio_dev,
-				  struct iio_chan_spec const *chan,
-				  int *val, int *val2, long mask)
+                                  struct iio_chan_spec const *chan,
+                                  int *val, int *val2, long mask)
 {
-	struct eaapmst3923a2_data *data = iio_priv(indio_dev);
-	unsigned int lo, hi;
-	int ret;
-
-	if (mask != IIO_CHAN_INFO_RAW)
-		return -EINVAL;
-
-	switch (chan->type) {
-	case IIO_LIGHT:
-		ret = regmap_read(data->regmap, EAAPMST3923A2_REG_ALS_LOW, &lo);
-		if (ret < 0) return ret;
-		ret = regmap_read(data->regmap, EAAPMST3923A2_REG_ALS_HIGH, &hi);
-		if (ret < 0) return ret;
-		*val = (hi << 8) | lo;
-
-		dev_info(&data->client->dev, "ALS raw read: lo=%02x hi=%02x val=%d\n", lo, hi, *val);
-		return IIO_VAL_INT;
-
-	case IIO_PROXIMITY:
-		ret = regmap_read(data->regmap, EAAPMST3923A2_REG_PS_LOW, &lo);
-		if (ret < 0) return ret;
-		ret = regmap_read(data->regmap, EAAPMST3923A2_REG_PS_HIGH, &hi);
-		if (ret < 0) return ret;
-		*val = (hi << 8) | lo;
-
-		dev_info(&data->client->dev, "Proximity raw read: lo=%02x hi=%02x val=%d\n", lo, hi, *val);
-		return IIO_VAL_INT;
-
-	default:
-		return -EINVAL;
-	}
+        struct eaapmst3923a2_data *data = iio_priv(indio_dev);
+        unsigned int lo, hi;
+        int ret;
+
+        if (mask != IIO_CHAN_INFO_RAW)
+                return -EINVAL;
+
+        switch (chan->type) {
+        case IIO_LIGHT: /* ALS */
+                ret = regmap_read(data->regmap, EAAPMST3923A2_REG_ALS_LOW, &lo);
+                if (ret < 0) return ret;
+
+                ret = regmap_read(data->regmap, EAAPMST3923A2_REG_ALS_HIGH, &hi);
+                if (ret < 0) return ret;
+
+                *val = ((hi & 0x0F) << 8) | lo;
+
+                dev_info(&data->client->dev,
+                         "ALS raw read: lo=%02x hi=%02x val=%d\n", lo, hi, *val);
+                return IIO_VAL_INT;
+
+        case IIO_PROXIMITY: /* PS */
+                ret = regmap_read(data->regmap, EAAPMST3923A2_REG_PS_DATA, &lo);
+                if (ret < 0) return ret;
+
+                *val = lo;
+
+                dev_info(&data->client->dev,
+                         "Proximity raw read: val=%d\n", *val);
+                return IIO_VAL_INT;
+
+        default:
+                return -EINVAL;
+        }
 }
 
 /* Define the IIO channels */
 static const struct iio_chan_spec eaapmst3923a2_channels[] = {
-	{
-		.type = IIO_LIGHT,
-		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
-	},
-	{
-		.type = IIO_PROXIMITY,
-		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
-	},
+        {
+                .type = IIO_LIGHT,
+                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+        },
+        {
+                .type = IIO_PROXIMITY,
+                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
+        },
 };
 
 static const struct iio_info eaapmst3923a2_info = {
-	.read_raw = eaapmst3923a2_read_raw,
+        .read_raw = eaapmst3923a2_read_raw,
 };
 
 static const struct regmap_config eaapmst3923a2_regmap_config = {
@@ -79,68 +82,76 @@ static const struct regmap_config eaapmst3923a2_regmap_config = {
     .val_bits = 8,
 };
 
-
-
 /* I2C probe */
 static int eaapmst3923a2_probe(struct i2c_client *client,
-			       const struct i2c_device_id *id)
+                               const struct i2c_device_id *id)
 {
-	struct iio_dev *indio_dev;
-	struct eaapmst3923a2_data *data;
-	struct regmap *regmap;
-	int ret;
-
-	regmap = devm_regmap_init_i2c(client, &eaapmst3923a2_regmap_config);
-	if (IS_ERR(regmap))
-		return PTR_ERR(regmap);
-
-	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
-	if (!indio_dev)
-		return -ENOMEM;
-
-	data = iio_priv(indio_dev);
-	data->client = client;
-	data->regmap = regmap;
-
-	indio_dev->dev.parent = &client->dev;
-	indio_dev->info = &eaapmst3923a2_info;
-	indio_dev->modes = INDIO_DIRECT_MODE;
-	indio_dev->channels = eaapmst3923a2_channels;
-	indio_dev->num_channels = ARRAY_SIZE(eaapmst3923a2_channels);
-
-	/* Enable ALS + PS (example, depends on datasheet init sequence) */
-	ret = i2c_smbus_write_byte_data(client, EAAPMST3923A2_REG_ENABLE, 0x03);
-	if (ret < 0)
-		return ret;
-	msleep(120);
-	return devm_iio_device_register(&client->dev, indio_dev);
+        struct iio_dev *indio_dev;
+        struct eaapmst3923a2_data *data;
+        struct regmap *regmap;
+        int ret;
+
+        regmap = devm_regmap_init_i2c(client, &eaapmst3923a2_regmap_config);
+        if (IS_ERR(regmap))
+                return PTR_ERR(regmap);
+
+        indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+        if (!indio_dev)
+                return -ENOMEM;
+
+        data = iio_priv(indio_dev);
+        data->client = client;
+        data->regmap = regmap;
+
+        indio_dev->dev.parent = &client->dev;
+        indio_dev->info = &eaapmst3923a2_info;
+        indio_dev->modes = INDIO_DIRECT_MODE;
+        indio_dev->channels = eaapmst3923a2_channels;
+        indio_dev->num_channels = ARRAY_SIZE(eaapmst3923a2_channels);
+
+        /* Configure: enable ALS + PS */
+        ret = i2c_smbus_write_byte_data(client, EAAPMST3923A2_REG_CONFIG, 0xBC);
+        if (ret < 0)
+                return ret;
+
+        /* Set ALS range = 100 lux (sensitive indoors) */
+        ret = i2c_smbus_write_byte_data(client, EAAPMST3923A2_REG_ALS_RANGE, 0x03);
+        if (ret < 0)
+                return ret;
+
+        /* Wait for first ALS conversion (~100 ms) */
+        msleep(120);
+
+        dev_info(&client->dev, "EAAPMST3923A2 sensor initialized\n");
+
+        return devm_iio_device_register(&client->dev, indio_dev);
 }
 
 static int eaapmst3923a2_remove(struct i2c_client *client)
 {
-	return 0;
+        return 0;
 }
 
 static const struct of_device_id eaapmst3923a2_of_match[] = {
-    	{ .compatible = "eaap,pmst3923a2" },
-    	{ }
+        { .compatible = "eaap,pmst3923a2" },
+        { }
 };
 MODULE_DEVICE_TABLE(of, eaapmst3923a2_of_match);
 
-
 static const struct i2c_device_id eaapmst3923a2_id[] = {
-	{ "eaapmst3923a2", 0 },
-	{ }
+        { "eaapmst3923a2", 0 },
+        { }
 };
 MODULE_DEVICE_TABLE(i2c, eaapmst3923a2_id);
 
 static struct i2c_driver eaapmst3923a2_driver = {
-	.driver = {
-		.name = "eaapmst3923a2", .of_match_table = eaapmst3923a2_of_match,
-	},
-	.probe = eaapmst3923a2_probe,
-	.remove = eaapmst3923a2_remove,
-	.id_table = eaapmst3923a2_id,
+        .driver = {
+                .name = "eaapmst3923a2",
+                .of_match_table = eaapmst3923a2_of_match,
+        },
+        .probe = eaapmst3923a2_probe,
+        .remove = eaapmst3923a2_remove,
+        .id_table = eaapmst3923a2_id,
 };
 module_i2c_driver(eaapmst3923a2_driver);
 
-- 
2.25.1

